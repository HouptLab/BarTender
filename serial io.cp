static void PrintInfoAboutAllSerialPorts(void);static OSErr OpenOneSerialDriver(ConstStr255Param driverName, short *refNum);static OSErr OpenSerialDrivers(ConstStr255Param inName, ConstStr255Param outName, SInt16 *inRefNum, SInt16 *outRefNum);static Boolean SerialArbitrationExists(void);static Boolean DriverIsOpen(ConstStr255Param driverName);static void PrintInfoAboutAllSerialPorts(void)    // Prints a list of all the serial ports on the    // machine, along with their corresponding input    // and output driver names, to stdout.  Typically    // you would use a routine like this to populate a    // popup menu of the available serial ports.{    CRMRec          commRecord;    CRMRecPtr       thisCommRecord;    CRMSerialPtr    serialPtr;            (void) InitCRM();        // First set up commRecord to specify that    // we're interested in serial devices.        commRecord.crmDeviceType = crmSerialDevice;    commRecord.crmDeviceID   = 0;Ê    // Now repeatedly call CRMSearch to iterate    // through all the serial ports.Ê    thisCommRecord = &commRecord;    do {        thisCommRecord = (CRMRecPtr) CRMSearch( (CRMRecPtr) thisCommRecord );        if ( thisCommRecord != nil ) {                        // Once we a have a CRMRec for the serial port,            // we must cast the crmAttributes field to            // a CRMSerialPtr to access to serial-specific            // fields about the port.Ê            serialPtr = (CRMSerialPtr) thisCommRecord->crmAttributes;Ê            // Print the information about the port.                        printf("We have a port called: '%#s'\n", *(serialPtr->name));            printf("   input driver named: '%#s'\n", *(serialPtr->inputDriverName));            printf("  output driver named: '%#s'\n", *(serialPtr->outputDriverName));            printf("\n");Ê            // Now ensure that CRMSearch finds the next device.                        commRecord.crmDeviceID = thisCommRecord->crmDeviceID;        }    } while ( thisCommRecord != nil );}Ê/*NOTE:The CRM is available in System 7.0 and later. It is an installable option under System 6. If your product runs under System 6, you should check for the presence of the CRM by calling Gestalt with the gestaltCRMAttr selector and checking that the gestaltCRMPresent bit is set in the response. IMPORTANT:Ports registered with the CRM are supposed to "work like" the standard built-in serial ports.However, in some cases (both Apple and third party), it's just not possible to implement the APIof the built-in serial ports exactly. When dealing with CRM-registered ports, your application should handle cases where this emulation breaks down. For example, if your application uses the externally clocked quasi-MIDI mode (csCode 15),it should gracefully fail if a serial driver returns an error when asked to engage this mode. Opening a Serial PortThe correct way to open a serial port has been documented for many years as part of the ARA API document, currently available on the Mac OS SDK Developer CDs. However, this source is somewhat obscure (and the enclosed sample code is somewhat out of date),  so the information is repeated here for your convenience.The process is very easy to describe in English:If a serial port arbitrator is installed, always call OpenDriver to open the serial port;otherwise, walk the unit table to determine whether the driver is already open, and open it only if it isn't.This high-level algorithm is captured in the following routines for openingboth the input and output serial drivers:*/static OSErr OpenOneSerialDriver(ConstStr255Param driverName, short *refNum)    // The one true way of opening a serial driver.  This routine    // tests whether a serial port arbitrator exists.  If it does,    // it relies on the SPA to do the right thing when OpenDriver is called.    // If not, it uses the old mechanism, which is to walk the unit table    // to see whether the driver is already in use by another program.{    OSErr err;        if ( SerialArbitrationExists() ) {        err = OpenDriver(driverName, refNum);    } else {        if ( DriverIsOpen(driverName) ) {            err = portInUse;        } else {            err = OpenDriver(driverName, refNum);        }    }    return err;}Êstatic OSErr OpenSerialDrivers(ConstStr255Param inName, ConstStr255Param outName,                                 SInt16 *inRefNum, SInt16 *outRefNum)    // Opens both the input and output serial drivers, and returns their    // refNums.  Both refNums come back as an illegal value (0) if we    // can't open either of the drivers.{    OSErr err;        err = OpenOneSerialDriver(outName, outRefNum);    if (err == noErr) {        err = OpenOneSerialDriver(inName, inRefNum);        if (err != noErr) {            (void) CloseDriver(*outRefNum);        }    }    if (err != noErr) {        *inRefNum = 0;        *outRefNum = 0;    }    return err;}/*The above code opens the output serial driver before opening the input serial driver.This is the recommended order for the built-in serial drivers, and consequently forother CRM-registered serial drivers. This is because the output driver is the onethat reserves system resources and actually checks for the availability of the port.For the built-in serial ports, if you successfully open the output driver, you should always be able to open the input driver. Not all CRM-registered serial drivers work this way, however, so your code shouldalways check the error result from both opens.The code for determining whether a serial port arbitrator is installed is shown below:*/enum {    gestaltSerialPortArbitratorAttr = 'arb ',            gestaltSerialPortArbitratorExists = 0};Êstatic Boolean SerialArbitrationExists(void)    // Test Gestalt to see if serial arbitration exists    // on this machine.{    Boolean result;    long    response;        result = ( Gestalt(gestaltSerialPortArbitratorAttr, &response) == noErr &&                (response & (1 << gestaltSerialPortArbitratorExists) != 0)  != 0)                 );    return result;}static Boolean DriverIsOpen(ConstStr255Param driverName)    // Walks the unit table to determine whether the    // given driver is marked as open in the table.    // Returns false if the driver is closed, or does    // not exist.{    Boolean     found;    Boolean     isOpen;    short       unit;    DCtlHandle  dceHandle;    StringPtr   namePtr;        found = false;    isOpen = false;        unit = 0;       while ( ! found && ( unit < LMGetUnitTableEntryCount() ) ) {            // Get handle to a device control entry.  GetDCtlEntry        // takes a driver refNum, but we can convert between        // a unit number and a driver refNum using bitwise not.                dceHandle = GetDCtlEntry( ~unit );                if ( dceHandle != nil && (**dceHandle).dCtlDriver != nil ) {                    // If the driver is RAM based, dCtlDriver is a handle,            // otherwise it's a pointer.  We have to do some fancy            // casting to handle each case.  This would be so much            // easier to read in Pascal )-:                        if ( ((**dceHandle).dCtlFlags & dRAMBasedMask) != 0 ) {                namePtr = & (**((DRVRHeaderHandle) (**dceHandle).dCtlDriver)).drvrName[0];            } else {                namePtr = & (*((DRVRHeaderPtr) (**dceHandle).dCtlDriver)).drvrName[0];            }                // Now that we have a pointer to the driver name, compare            // it to the name we're looking for.  If we find it,            // then we can test the flags to see whether it's open or            // not.                        if ( EqualString(driverName, namePtr, false, true) ) {                found = true;                isOpen = ((**dceHandle).dCtlFlags & dOpenedMask) != 0;            }        }        unit += 1;    }        return isOpen;}