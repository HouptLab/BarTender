// exptGroups#include "BarObjects.hpp"#define GROUPDIAL 146#define OK 1#define CANCEL 2#define NAME 3#define EXABR 4#define NUMGROUPS 5#define SEQUENTIAL 6#define ALTERNATING 7#define LABEL1 89#define GROUP1 8#define	ABBR1 18#define SUBJECT1 28#define SUBJECT_LABEL1 104#define MAXSUBJ 60Boolean SetGroups(Experiment *expt);void DisplayGroups(DialogPtr d, Experiment *expt,unsigned long  numGroups);Boolean GetGroupValues(DialogPtr d, Experiment *expt);void DisplayRatAssignments(DialogPtr d, Experiment *expt);GroupType *PopUpAllGroups(Rect box, Point *pt,short currItem,Experiment *expt);Boolean SetSubjectGroup(DialogPtr d, Experiment *expt,unsigned long item);void SetGroupColor(unsigned long groupIndex);Boolean IsAllLetters(char *text); // defined in Editexpt.cpBoolean SetGroups(Experiment *expt) {	short item;	DialogPtr d;	Experiment *backexpt;	unsigned long numGroups,newNumGroups;	char text[256];	// puts up a modal dialog which allows you to tinker		d = GetNewDialog(GROUPDIAL,0L,(WindowPtr)-1L);//EREMEMBER TO ADD GROUPS TO BACKUP	numGroups = expt->groups->GetNumMembers();	DisplayGroups(d,expt,numGroups);	DisplayRatAssignments(d,expt);	DrawDialog(d);	FrameDefault(d);	InitCursor();		do {			ModalDialog(0L,&item);			switch (item) {								case NUMGROUPS:				GetDULong(d,NUMGROUPS,&newNumGroups);				if (newNumGroups != 0 && newNumGroups != numGroups) {					numGroups = newNumGroups;					if (numGroups > MAXGROUPS) numGroups = MAXGROUPS;					DisplayGroups(d,expt,numGroups);					DrawDialog(d);					FrameDefault(d);				}				break;											case CANCEL:				DisposDialog(d);				return(FALSE);				break;							case SEQUENTIAL:				if (GetGroupValues(d,expt)) {					expt->SetSequentialGroups();					DisplayRatAssignments(d,expt);					DrawDialog(d);					FrameDefault(d);				}				break;						case ALTERNATING:				if (GetGroupValues(d,expt)) {					expt->SetAlternatingGroups();					DisplayRatAssignments(d,expt);					DrawDialog(d);					FrameDefault(d);				}				break;														case OK:								if (GetGroupValues(d,expt)) {					DisposDialog(d);					return(TRUE);				}				else {					numGroups = expt->groups->GetNumMembers();					DisplayGroups(d,expt,numGroups);					DrawDialog(d);					FrameDefault(d);							}				break;		} 				if (SUBJECT1 <= item && item < SUBJECT1 + MAXSUBJ) {								if (SetSubjectGroup(d,expt,item)) {								DisplayRatAssignments(d,expt);					DrawDialog(d);					FrameDefault(d);						}				}		} while (TRUE);		DisposDialog(d);	return (FALSE);}void DisplayRatAssignments(DialogPtr d, Experiment *expt) {	unsigned long numRats,lastRat,i,ratGroup;	char groupName[256],groupTag[32];	Handle itemhandle;      	short itemkind;      	Rect itembox;     RGBColor oldColor;      		numRats = expt->rats->GetNumMembers();		if (numRats <= MAXSUBJ) lastRat = numRats;	else lastRat = MAXSUBJ;		for (i=0;i<lastRat;i++) {		ShowDItem(d,SUBJECT_LABEL1 + i);		ShowDItem(d,SUBJECT1 + i);		ratGroup = ((RatType *)(expt->rats->GetMember(i)))->group;		strcpy(groupName,((GroupType *)(expt->groups->GetMember(ratGroup)))->tag);		SetDText(d,SUBJECT1 + i,groupName);		GetDItem(d,SUBJECT1 + i,&itemkind,&itemhandle,&itembox);		itembox.left-= 2;		SetPort(d);				GetForeColor(&oldColor);		SetGroupColor(ratGroup);		MFrame(&itembox);		RGBForeColor(&oldColor);	}	for (i=lastRat;i< MAXSUBJ;i++) {		HideDItem(d,SUBJECT_LABEL1 + i);		HideDItem(d,SUBJECT1 + i);	}}void DisplayGroups(DialogPtr d, Experiment *expt,unsigned long  numGroups) {	unsigned long lastGroup,i;	char groupName[256],groupTag[32];	SetDText(d,NAME,expt->name);	SetDText(d,EXABR,expt->tag);			expt->SetNumGroups(numGroups);	numGroups = expt->groups->GetNumMembers();	SetDULong(d,NUMGROUPS,numGroups);		if (numGroups <= MAXGROUPS) lastGroup = numGroups;	else lastGroup = MAXGROUPS;		for (i=0;i<lastGroup;i++) {		ShowDItem(d,LABEL1 + i);		ShowDItem(d,GROUP1 + i);		ShowDItem(d,ABBR1 + i);		strcpy(groupName,((GroupType *)(expt->groups->GetMember(i)))->name);		strcpy(groupTag,((GroupType *)(expt->groups->GetMember(i)))->tag);		SetDText(d,GROUP1 + i,groupName);		SetDText(d,ABBR1 + i,groupTag);	}	for (i=lastGroup;i< MAXGROUPS;i++) {		HideDItem(d,LABEL1 + i);		HideDItem(d,GROUP1 + i);		HideDItem(d,ABBR1 + i);	}}Boolean GetGroupValues(DialogPtr d, Experiment *expt) {	unsigned long numRats, numGroups;	unsigned long i,numGroupFields;	char groupName[256],groupTag[32];		Boolean lengthFlag = FALSE, numGroupsFlag = FALSE;					GetDULong(d,NUMGROUPS,&numGroups);	if (numGroups == 0) {				numGroupsFlag = TRUE;		numGroups = 1;		}		// POST ALERT!		// need to be at least 1 group				numGroupFields = expt->groups->GetNumMembers();		for (i=0;i<numGroupFields;i++) {		GetDText(d,GROUP1 + i,groupName);			// tag needs to be non-zero in length					if (strlen(groupName) == 0) {			lengthFlag = TRUE;			sprintf(groupName,"GROUP%d",i+1);				}				strcpy(((GroupType *)(expt->groups->GetMember(i)))->name,groupName);			GetDText(d,ABBR1 + i,groupTag);		// tag needs to be non-zero in length		// tag needs to be all letters				if (strlen(groupTag) == 0) {			lengthFlag = TRUE;			sprintf(groupTag,"%c",i+'A');		}				strcpy( ((GroupType *)(expt->groups->GetMember(i)))->tag,groupTag);							}		expt->SetNumGroups(numGroups);	#define LENGTHID 134#define LETTERSID 135#define NUMITEMID 137	if (lengthFlag) {		Alert(LENGTHID,0L);ResetAlrtStage();	}		if (numGroupsFlag) {		Alert(NUMITEMID,0L);ResetAlrtStage();	}	return(!lengthFlag  && !numGroupsFlag);}Boolean SetSubjectGroup(DialogPtr d, Experiment *expt,unsigned long item) {		Handle itemhandle;      	short itemkind;      	Rect popbox;            unsigned long subj,groupIndex,newGroupIndex;      RatType *rat;	GroupType *group;	Point pt;      		subj = item - SUBJECT1;		if (subj > expt->GetNumRats()) return (FALSE);	rat = (RatType *)(expt->rats->GetMember(subj));		GetMouse(&pt);	groupIndex = 0;	groupIndex = rat->group;	GetDItem(d,item,&itemkind,&itemhandle,&popbox);		group = PopUpAllGroups(popbox,&pt,groupIndex,expt);	if (group != NULL) {				newGroupIndex = expt->GetGroupIndex(group);		if (newGroupIndex != groupIndex) {			rat->group = newGroupIndex;			return(TRUE);		}	}		return(FALSE);}#define POPGROUP_MENU 144GroupType *PopUpAllGroups(Rect box, Point *pt,short currItem,Experiment *expt) {	long result;	Point popPt;	// set up the menu	char text[256];	short i;	short menuID;	MenuHandle menu;	GroupType	*group;	unsigned long numGroups;		// note: add 1 to item index because menus are 1 indexed	// note: add newOffset = 2 if the "New" item and separator line are being used.						menuID = POPGROUP_MENU;		sprintf(text,"Groups");CtoPstr(text);	menu = NewMenu(menuID,(unsigned char *)text);				// set up menu of expts:	numGroups = expt->GetNumGroups();		for (i=0;i<numGroups;i++) {			// have to insert a dummy text name, then reset the name		// to avoid control character stuff.		sprintf(text ,"Dummy");		CtoPstr(text);		AppendMenu(menu,(unsigned char *)text);				group = (GroupType *)(expt->groups->GetMember(i));				strcpy(text,group->name);		CtoPstr(text);		SetItem(menu,i+1,(unsigned char *)text);	//	SetItemCmd(menu, currItem+1,0x1e);		// have to use set item to get any slashes to appear correctly				}			popPt.h = (short)box.left;	popPt.v = (short)box.top + (   (((short)pt->v - (short)box.top)/ 16) * 16);	LocalToGlobal(&popPt);	InsertMenu(menu,-1);	result = PopUpMenuSelect(menu,popPt.v,popPt.h,currItem + 1);		DeleteMenu(menuID);		group = NULL;	if (HiWord(result) == menuID) {		currItem = LoWord(result) - 1;								if (currItem >= 0) {							if (currItem < numGroups) {									group = (GroupType *)(expt->groups->GetMember(currItem));								}							}			}		return(group);	}void SetGroupColor(unsigned long groupIndex) {RGBColor groupColor[] = { 							{0,		0,		0},//black							{0xffff,0,	0}, // red							{0,		48059,	0}, // green							{0,		0,		0xd400}, // blue							{65535,26214,	13107}, // orange							{39321,0,	52428},  // purple							{0xffff,0xffff,	0}, // yellow							{48059,48059,	48059}, // light gray							{30583,30583,	30583}, // med gray							{17476,17476,	17476}	// dark gray												};RGBForeColor(&groupColor[groupIndex]);}