  
	// set up time for updating the displayed weight
	
	// NOTE: modify this to check if balance is not available?
	
	//(NSInvocation *)invocation // set this to [aboutWindow OrderOut:nil];
	
    
   // look at this post to make weight timer into another object..
// http://stackoverflow.com/questions/4945028/repeating-nstimer-weak-reference-owning-reference-or-ivar?rq=1

//    NSTimeInterval updateWeightTime = kUpdateWeightDisplayInterval; // display for, e.g., 0.1 seconds
//
//    self.weightTimer = [NSTimer scheduledTimerWithTimeInterval:updateWeightTime  target:self selector:@selector(updateWeightDisplay:) userInfo:NULL repeats:YES];
    
// self.weightTimer = [NSTimer BCscheduledTimerWithTimeInterval:updateWeightTime  weakTarget:self selector:@selector(updateWeightDisplay:) userInfo:NULL repeats:YES logsDeallocation:YES];
    
//    +(NSTimer *)BCscheduledTimerWithTimeInterval:(NSTimeInterval)ti weakTarget:(id)target selector:(SEL)selector userInfo:(id)userInfo repeats:(BOOL)shouldRepeat logsDeallocation:(BOOL)shouldLogDealloc;    
    
	
  //  [self.weightTimer invalidate];
	
    
 //   [self setWeightTimer];
    
  
  
  //-(void)setWeightTimer; {
//    
//    // code taken from http://codeshaker.blogspot.com/2012/07/nstimer-alternative.html by Andras
//    // modified for ARC as per http://stackoverflow.com/questions/8915981/block-self-reference-cycle-in-ivar-block-in-arc
//    // see also http://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html
//    
// //   id __weak weakSelf = self;
//    
////   __unsafe_unretained DailyDataDocument *weakSelf = self;
//    __unsafe_unretained id weakSelf = self;
//
//    // use __weak instead of __block before void (^timer)(void)
//    __block void (^timer)(void) = ^{
//        
//        int64_t delayInNanoSeconds = NSEC_PER_SEC / 10;
//        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInNanoSeconds);
//        dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
//            
//            id strongSelf = weakSelf;
//  //          DailyDataDocument *strongSelf = weakSelf;
//            if (!strongSelf) {
//                return;
//            }
//            
//            // Schedule the timer again
//           timer();
//            
//            // Always use strongSelf when calling a method or accessing an iVar
////            [strongSelf doSomething];
////            strongSelf->anIVar = 0;
//            
//            [strongSelf updateWeightDisplay];
//        });
//    };
//    
//    // Start the timer for the first time
//    timer();
//
//    
//}


-(void)close; {
    
    [super close];
    
}
-(void)cleanUpAndClose; {
	
    NSLog(@"DailyDocument cleanUpAndClose");
    
// 
//    if (weightTimer != nil) {
//        [self.weightTimer invalidate];
//       // NSTimer *tempTimer = self.weightTimer;
//       self.weightTimer = nil;
//    //    [tempTimer invalidate];
//    }
//    
     NSLog(@"DailyDocument cleanUpAndClose finished");
	
}

//-(void)close; {
//    
//    NSLog(@"DailyDocument close");
//    
//    
// //   [self cleanUpBeforeClosing];
//   [super close];
//    //    NSLog(@"DailyDocument closing: back from super close");
//
//    
//    NSLog(@"DailyDocument close finished");
//
//    
//}
//
//- (void) document:(NSDocument*)doc shouldClose:(BOOL)shouldClose contextInfo:(void*)contextInfo; {
//    
//    NSLog(@"DailyDocument shouldClose");
//
//    if (YES == shouldClose) {
//        [doc close];
//    }
//    
//    NSLog(@"DailyDocument shouldClose finished");
//
//}
//
//
//- (void)canCloseDocumentWithDelegate: (id)delegate
//                 shouldCloseSelector: (SEL)shouldCloseSelector
//                         contextInfo: (void*)contextInfo; {
//    
//    NSMethodSignature *ms;
//    NSInvocation *inv;
//    BOOL shouldClose;
//    
//    NSLog(@"DailyDocument canCloseDocumentWithDelegate ");
//
//    // Do whatever document-specific processing is needed here. If the document
//    // is not dirty, shouldClose can be set to YES. If the document is dirty, you can
//    // present a sheet or dialog asking if the user wants to save it,and set shouldClose
//    // according to the results of that.
//    
//    [self cleanUpBeforeClosing];
//    
//    // Just to be paranoid, verify that the delegate responds to the given selector
//
//    if ([delegate respondsToSelector:shouldCloseSelector]) {
//        
//        // Create the invocation object
//        ms = [delegate methodSignatureForSelector:shouldCloseSelector];
//        inv = [NSInvocation invocationWithMethodSignature:ms];
//        
//        // Set the target, selector, and parameters
//        [inv setTarget:delegate];
//        [inv setSelector:shouldCloseSelector];
//        [inv setArgument:(__bridge void *)(self) atIndex:2];
//        [inv setArgument:&shouldClose atIndex:3];
//        [inv setArgument:&contextInfo atIndex:4];
//        
//        // Invoke!
//        [inv invoke];
//    }
//    
//    NSLog(@"DailyDocument canCloseDocumentWithDelegate finished");
//
//}
//


