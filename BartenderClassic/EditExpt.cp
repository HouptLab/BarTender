#include "BarObjects.hpp"#define EXPTDIAL 129#define OK 1#define CANCEL 2#define NAME 3#define EXABR 4#define COMMENT 5#define NUMRATS 6#define NUMITEMS 7#define ITEM1 8#define	ABBR1 14#define LABEL1 21#define PREFERENCE 34#define PREFTEXT 33#define GROUPS 35#define MAXITEMS 6void DisplayValues(DialogPtr d, Experiment *expt,unsigned long numItems);void DisplayItems(DialogPtr d, Experiment *expt,unsigned long numItems);Boolean GetValues(DialogPtr d, Experiment *expt);Experiment *BackupValues(Experiment *expt);void RetrieveBackups(Experiment *expt,Experiment *backup);Experiment *ChooseExpt(void);Experiment *PopUpAllExpts(Rect box, Point *pt,short modifiers);Boolean IsAllLetters(char *text);Boolean SetGroups(Experiment *expt); // defined in ExptGroups.cpBoolean EditExperiment(Experiment *expt) {	short item;	DialogPtr d;	Experiment *backexpt;	unsigned long numItems,newNumItems;	char text[256];	// puts up a modal dialog which allows you to tinker			d = GetNewDialog(EXPTDIAL,0L,(WindowPtr)-1L);	backexpt = BackupValues(expt);	numItems = expt->items->GetNumMembers();	DisplayValues(d,expt,numItems);	expt->GetPreferenceText(text);	SetDText(d,PREFTEXT,text);			FrameDefault(d);	InitCursor();		do {			ModalDialog(0L,&item);			switch (item) {								case NUMITEMS:				GetDULong(d,NUMITEMS,&newNumItems);				if (newNumItems != 0 && newNumItems != numItems) {					numItems = newNumItems;					if (numItems > MAXITEMS) numItems = MAXITEMS;					DisplayItems(d,expt,numItems);				}				break;											case CANCEL:				RetrieveBackups(expt,backexpt);				if (backexpt != NULL) delete backexpt;				DisposDialog(d);				return(FALSE);				break;							case GROUPS:				if (GetValues(d,expt)) {					SetGroups(expt);					DrawDialog(d);					FrameDefault(d);				}				break;										case PREFERENCE:				if (GetValues(d,expt)) {					if (SetPreference(expt)) {						expt->GetPreferenceText(text);						SetDText(d,PREFTEXT,text);					}					DrawDialog(d);					FrameDefault(d);								}				break;							case OK:								if (GetValues(d,expt)) {					if (backexpt != NULL) delete backexpt;					DisposDialog(d);					return(TRUE);				}				else {					numItems = expt->items->GetNumMembers();					DisplayValues(d,expt,numItems);								}				break;		} 		} while (TRUE);		DisposDialog(d);	return (FALSE);}void DisplayValues(DialogPtr d, Experiment *expt,unsigned long  numItems) {	SetDText(d,NAME,expt->name);	SetDText(d,EXABR,expt->tag);	SetDText(d,COMMENT,expt->comment);		SetDULong(d,NUMRATS,expt->rats->GetNumMembers());	SetDULong(d,NUMITEMS,numItems);		DisplayItems(d,expt,numItems);	}void DisplayItems(DialogPtr d, Experiment *expt,unsigned long numItems) {	unsigned long lastItem,i;	char itemName[256],itemTag[32];		expt->SetNumItems(numItems);	numItems = expt->items->GetNumMembers();		if (numItems <= MAXITEMS) lastItem = numItems;	else lastItem = MAXITEMS;		for (i=0;i<lastItem;i++) {		ShowDItem(d,LABEL1 + i);		ShowDItem(d,ITEM1 + i);		ShowDItem(d,ABBR1 + i);		strcpy(itemName,((ItemType *)(expt->items->GetMember(i)))->name);		strcpy(itemTag,((ItemType *)(expt->items->GetMember(i)))->tag);		SetDText(d,ITEM1 + i,itemName);		SetDText(d,ABBR1 + i,itemTag);	}	for (i=lastItem;i< MAXITEMS;i++) {		HideDItem(d,LABEL1 + i);		HideDItem(d,ITEM1 + i);		HideDItem(d,ABBR1 + i);	}}Boolean GetValues(DialogPtr d, Experiment *expt) {	unsigned long numRats, numItems;	unsigned long i,numItemFields;	char itemName[256],itemTag[32];		Boolean lengthFlag = FALSE, lettersFlag = FALSE, numRatsFlag = FALSE, numItemsFlag = FALSE;		GetDText(d,NAME,expt->name);	if (strlen(expt->name) == 0) {		lengthFlag = TRUE;	}	GetDText(d,EXABR,expt->tag);	if (strlen(expt->tag) == 0) {		lengthFlag = TRUE;	}	else if (! IsAllLetters(expt->tag) ) {		lettersFlag = TRUE;	}			// experiment tag must be all letters	GetDText(d,COMMENT,expt->comment);		GetDULong(d,NUMRATS,&numRats);	if (numRats == 0) {		numRats = 1;		numRatsFlag = TRUE;	}	GetDULong(d,NUMITEMS,&numItems);	if (numItems == 0) {				numItemsFlag = TRUE;		numItems = 1;		}		// POST ALERT!		// need to be at least 1 item		// need to be at least 1 rat				numItemFields = expt->items->GetNumMembers();		for (i=0;i<numItemFields;i++) {		GetDText(d,ITEM1 + i,itemName);			// tag needs to be non-zero in length					if (strlen(itemName) == 0) {			lengthFlag = TRUE;			sprintf(itemName,"ITEM%d",i+1);				}				strcpy(((ItemType *)(expt->items->GetMember(i)))->name,itemName);			GetDText(d,ABBR1 + i,itemTag);		// tag needs to be non-zero in length		// tag needs to be all letters				if (strlen(itemTag) == 0) {			lengthFlag = TRUE;			sprintf(itemTag,"%c",i+'A');		}		else if (!IsAllLetters(itemTag)) {			lettersFlag = TRUE;		}				strcpy( ((ItemType *)(expt->items->GetMember(i)))->tag,itemTag);							}		expt->SetNumItems(numItems);	expt->SetNumRats(numRats);	#define LENGTHID 134#define LETTERSID 135#define NUMRATSID 136#define NUMITEMID 137	if (lengthFlag) {		Alert(LENGTHID,0L);ResetAlrtStage();	}	if (lettersFlag) {		Alert(LETTERSID,0L);ResetAlrtStage();	}	if (numRatsFlag) {		Alert(NUMRATSID,0L);ResetAlrtStage();	}	if (numItemsFlag) {		Alert(NUMITEMID,0L);ResetAlrtStage();	}	return(!lengthFlag && !lettersFlag && !numRatsFlag && !numItemsFlag);}Experiment *BackupValues(Experiment *expt) {	return(NULL);}void RetrieveBackups(Experiment *expt,Experiment *backup) {}#define CHOOSEEXPT_DIAL 130#define POP_EXPT 3#define OK 1#define CANCEL 2Experiment *ChooseExpt(void) {	DialogPtr d;	short item;	Rect popbox;	Handle itemhandle;	short itemkind;	unsigned long exptIndex;	Point pt;	char text[50];	Experiment *expt;		// get the dialog from the resource file	d = GetNewDialog(CHOOSEEXPT_DIAL,0L,(WindowPtr)-1L);		expt= (Experiment *)(allExpts->GetMember(0));	if (expt != NULL) expt->GetName(text);	else sprintf(text,"<none>");	SetDText(d,POP_EXPT,text);	GetDItem(d,POP_EXPT,&itemkind,&itemhandle,&popbox);		SetPort(d);	DrawDialog(d);	MFrame(&popbox);	FrameDefault(d);		do {			ModalDialog(0L,&item);				switch (item) {							case POP_EXPT:				GetMouse(&pt);				exptIndex = 0;				allExpts->GetMemberIndex(expt,&exptIndex);				expt = (Experiment *)PopUpAllExpts(popbox,&pt,exptIndex);				if (expt != NULL) {					expt->GetName(text);					SetDText(d,POP_EXPT,text);				}				SetPort(d);				DrawDialog(d);				MFrame(&popbox);				FrameDefault(d);				break;							case CANCEL:				DisposDialog(d);				return (NULL);				break;				}	} while (item != OK);			DisposDialog(d);	return(expt);}#define POPEXPT_MENU 143Experiment *PopUpAllExpts(Rect box, Point *pt,short currItem) {	long result;	Point popPt;	// set up the menu	char text[256];	short i;	short menuID;	MenuHandle menu;	Experiment *expt;	unsigned long num_expts;		// note: add 1 to item index because menus are 1 indexed	// note: add newOffset = 2 if the "New" item and separator line are being used.						menuID = POPEXPT_MENU;		sprintf(text,"Expts");CtoPstr(text);	menu = NewMenu(menuID,(unsigned char *)text);				// set up menu of expts:	num_expts = allExpts->GetNumMembers();		for (i=0;i<num_expts;i++) {			// have to insert a dummy text name, then reset the name		// to avoid control character stuff.		sprintf(text ,"Dummy");		CtoPstr(text);		AppendMenu(menu,(unsigned char *)text);				expt = (Experiment *)allExpts->GetMember(i);				expt->GetName(text);		CtoPstr(text);		SetItem(menu,i+1,(unsigned char *)text);	//	SetItemCmd(menu, currItem+1,0x1e);		// have to use set item to get any slashes to appear correctly				}			popPt.h = (short)box.left;	popPt.v = (short)box.top + (   (((short)pt->v - (short)box.top)/ 16) * 16);	LocalToGlobal(&popPt);	InsertMenu(menu,-1);	result = PopUpMenuSelect(menu,popPt.v,popPt.h,currItem + 1);		DeleteMenu(menuID);		expt = NULL;	if (HiWord(result) == menuID) {		currItem = LoWord(result) - 1;								if (currItem >= 0) {							if (currItem < num_expts) {									expt = (Experiment *)allExpts->GetMember(currItem);								}							}			}		return(expt);	}Boolean IsAllLetters(char *text) {	unsigned long i,l;	l = strlen(text);		for (i=0;i<l;i++) {			if (! isalpha(text[i])) return(FALSE);	}	return(TRUE);}Boolean SetGroups(Experiment *expt);