#include "BarObjects.hpp"#include "TabText.hpp"#include "TransposeTabFile.hpp"void StripLastChar(char *t);void TagRat2Text(char *tag, short rat, char *text);Experiment::Experiment() {		sprintf(name,"Untitled");	tag[0] = '\0';	comment[0] = '\0';	start_time = SecsNow();	end_time = 0;	waiting_for_off = FALSE;	rats = new ListObject();	items = new ListObject();	groups = new ListObject();	useGroups = TRUE;	days_of_data = new ListObject();	current_day = NULL;	folder_dirID = NULL;	hasPreference = FALSE;		SetNumItems(0);	SetNumGroups(0);	SetNumRats(0);}Experiment::~Experiment() {}void Experiment::SetNewExptDefaults(void) {	SetNumItems(2);	SetNumGroups(2);	SetNumRats(12);}#include "BarObjects.hpp"void Experiment::SetNumItems(unsigned long numItems) {		unsigned long origNumItems;	unsigned long i;	ItemType *item;		if (numItems > MAXITEMS) numItems =MAXITEMS;		origNumItems = items->GetNumMembers();		if (numItems == origNumItems) {		return;	}	else if (numItems < origNumItems) {			for (i= origNumItems-1; i >= numItems;i--) {			item = (ItemType *)(items->GetMember(i));			items->RemoveMember(item);			delete item;		}		}	else if (numItems > origNumItems) {			while (items->GetNumMembers() < numItems) {			item = new ItemType(items->GetNumMembers());			items->AddMember(item);		}	}			}void Experiment::SetNumGroups(unsigned long numGroups) {		unsigned long origNumGroups;	unsigned long i;	GroupType *group;		if (numGroups > MAXGROUPS) numGroups = MAXGROUPS;		origNumGroups = groups->GetNumMembers();		if (numGroups == origNumGroups) {		return;	}	else if (numGroups < origNumGroups) {			for (i= origNumGroups-1; i >= numGroups;i--) {			group = (GroupType *)(groups->GetMember(i));			groups->RemoveMember(group);			delete group;		}		}	else if (numGroups > origNumGroups) {			while (groups->GetNumMembers() < numGroups) {			group = new GroupType(groups->GetNumMembers());			groups->AddMember(group);		}	}			}void Experiment::SetNumRats(unsigned long numRats) {	unsigned long orignumRats;	unsigned long i;	RatType *rat;		orignumRats = rats->GetNumMembers();		if (numRats == orignumRats) {		return;	}	else if (numRats < orignumRats) {			for (i= orignumRats-1; i >= numRats;i--) {			rat = (RatType *)(rats->GetMember(i));			rats->RemoveMember(rat);			delete rat;		}		}	else if (numRats > orignumRats) {			while (rats->GetNumMembers() < numRats) {			rat = new RatType(rats->GetNumMembers());			rats->AddMember(rat);		}	}			}void Experiment::InitializeOn(void) {}void Experiment::CleanUpOn(void){}void Experiment::InitializeOff(void){}void Experiment::CleanUpOff(void){}Boolean Experiment::WaitingForOff(void) { return(waiting_for_off); }Boolean Experiment::Save(void) {	FILE *fp;	Str255 name;	FInfo finderInfo;	OSErr err;		// to do the backing up prpoerly, save the file as "n.BAK"	// then swap "n" and "n.BAK" using file exchange call		SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program			// does the file exist already?	sprintf((char *)name,tag);	CtoPstr((char *)name);	err = GetFInfo(name,homeVol,&finderInfo);	if (err == fnfErr) {			// if not, create the expt data folder too...		// we'll skip the expt folders for the moment, store everything in the application folder		// CreateExptFolder();	}	else FixBackUps(tag,homeVol);	fp = fopen(tag,"w");		SaveExptParams(fp);	SaveRats(fp);	SaveItems(fp);	SaveGroups(fp);	fclose(fp);		SetFileSignature(tag,homeVol,'EXPT','BARt');		return(TRUE);}void Experiment::CreateExptFolder(void) {	char foldername[50];	OSErr err;	WDPBRec wd;		long parent_dirID;	long procID;	short parent_vRefNum;	sprintf(foldername,"%s data Ä",tag);	CtoPstr(foldername);		err= GetWDInfo (homeVol,&parent_vRefNum, &parent_dirID,&procID);	err = DirCreate(parent_vRefNum,parent_dirID,(unsigned char *)foldername,&folder_dirID);	}void Experiment::SaveExptParams(FILE *fp) {	fprintf(fp,name); fprintf(fp,"\n");	fprintf(fp,comment); fprintf(fp,"\n");	fprintf(fp,"Start_time: %ld\n",start_time);	fprintf(fp,"End_time: %ld\n",end_time);	fprintf(fp,"Waiting_for_off: %ld\n",(short)waiting_for_off);	fprintf(fp,"Preference: %ld\n",(short)hasPreference);	fprintf(fp,"prefItem: %ld\n",(short)prefItem);	fprintf(fp,"baseItem: %ld\n",(short)baseItem);		}void Experiment::LoadExptParams(FILE *fp) {	LineBuffer *line;	long temp;		line = NewLineBuffer(1000);		if (GetNextLine(line,fp)) { strcpy(name,line->text); StripLastChar(name); }	if (GetNextLine(line,fp)) { strcpy(comment,line->text); StripLastChar(comment); }	if (GetNextLine(line,fp)) sscanf(line->text,"Start_time: %ld",&start_time);	if (GetNextLine(line,fp)) sscanf(line->text,"End_time: %ld",&end_time);	if (GetNextLine(line,fp)) {			sscanf(line->text,"Waiting_for_off: %ld",&temp);			waiting_for_off = (Boolean)temp;	}	if (GetNextLine(line,fp)) {			sscanf(line->text,"Preference: %ld",&temp);			hasPreference = (Boolean)temp;	}	if (GetNextLine(line,fp)) sscanf(line->text,"prefItem: %ld",&prefItem);	if (GetNextLine(line,fp)) sscanf(line->text,"baseItem: %ld",&baseItem);}void Experiment::SaveRats(FILE *fp) {	RatType *r;	Object *o;			fprintf(fp,"Num_rats: %ld\n",rats->GetNumMembers());		FORALL( o,rats) {			r = (RatType *)o;			fprintf(fp,"ID: %ld\n",r->id);		fprintf(fp,"Group: %ld\n",r->group);		fprintf(fp,"Start_time: %ld\n",r->start_time);		fprintf(fp,"End_time: %ld\n",r->end_time);		}}void Experiment::LoadRats(FILE *fp) {	RatType *r;		LineBuffer *line;	unsigned long num_rats;	unsigned long i;		line = NewLineBuffer(1000);		if (GetNextLine(line,fp)) sscanf(line->text,"Num_rats: %ld",&num_rats);		for (i=0;i<num_rats;i++) {			r = new RatType(0);				if (GetNextLine(line,fp)) sscanf(line->text,"ID: %ld",&r->id);		if (GetNextLine(line,fp)) sscanf(line->text,"Group: %ld",&r->group);		if (GetNextLine(line,fp)) sscanf(line->text,"Start_time: %ld",&r->start_time);		if (GetNextLine(line,fp)) sscanf(line->text,"End_time: %ldx",&r->end_time);				rats->AddMember(r);	}}void Experiment::SaveItems(FILE *fp) {	ItemType *i;	Object *o;			fprintf(fp,"Num_items: %ld\n",items->GetNumMembers());		FORALL(o,items) {			i = (ItemType *)o;			fprintf(fp,i->name);fprintf(fp,"\n");		fprintf(fp,i->tag);fprintf(fp,"\n");		//fprintf(fp,"minWgt: %lf",i->minWgt);fprintf(fp,"\n");		//fprintf(fp,"maxWgt: %lf",i->maxWgt);fprintf(fp,"\n");	}}void Experiment::LoadItems(FILE *fp) {	ItemType *i;		LineBuffer *line;	unsigned long num_items;	unsigned long j;		line = NewLineBuffer(1000);		if (GetNextLine(line,fp)) sscanf(line->text,"Num_items: %ld",&num_items);		for (j=0;j<num_items;j++) {			i = new ItemType(0);				if (GetNextLine(line,fp)) { strcpy(i->name,line->text); StripLastChar(i->name); }		if (GetNextLine(line,fp)) { strcpy(i->tag,line->text); StripLastChar(i->tag); }				//if (GetNextLine(line,fp)) sscanf(line->text,"minWgt: %lf",&i->minWgt);		//if (GetNextLine(line,fp)) sscanf(line->text,"maxWgt: %lf",&i->maxWgt);						items->AddMember(i);	}}void Experiment::SaveGroups(FILE *fp) {	GroupType *i;	Object *o;			fprintf(fp,"Num_groups: %ld\n",groups->GetNumMembers());		FORALL(o,groups) {			i = (GroupType *)o;			fprintf(fp,i->name);fprintf(fp,"\n");		fprintf(fp,i->tag);fprintf(fp,"\n");		//fprintf(fp,"minWgt: %lf",i->minWgt);fprintf(fp,"\n");		//fprintf(fp,"maxWgt: %lf",i->maxWgt);fprintf(fp,"\n");	}}void Experiment::LoadGroups(FILE *fp) {	GroupType *i;		LineBuffer *line;	unsigned long num_groups;	unsigned long j;		line = NewLineBuffer(1000);		if (GetNextLine(line,fp)) sscanf(line->text,"Num_groups: %ld",&num_groups);		for (j=0;j<num_groups;j++) {			i = new GroupType(0);				if (GetNextLine(line,fp)) { strcpy(i->name,line->text); StripLastChar(i->name); }		if (GetNextLine(line,fp)) { strcpy(i->tag,line->text); StripLastChar(i->tag); }				//if (GetNextLine(line,fp)) sscanf(line->text,"minWgt: %lf",&i->minWgt);		//if (GetNextLine(line,fp)) sscanf(line->text,"maxWgt: %lf",&i->maxWgt);						groups->AddMember(i);	}}GroupType *Experiment::GetAGroup(unsigned long i) { return ((GroupType *)(groups->GetMember(i)));}short Experiment::GetGroupIndex(GroupType *i) {	unsigned long j;	for (j=0;j<GetNumGroups();j++) {			if (i == GetAGroup(j)) return(j);		}		return(-1);}void StripLastChar(char *t) {	t[strlen(t)-1] = '\0';}Boolean Experiment::Load(void) {	FILE *fp;		SetVol(0L,vRefNum);		fp = fopen(tag,"r");	if (fp == NULL) return(FALSE);		LoadExptParams(fp);	LoadRats(fp);	LoadItems(fp);	LoadGroups(fp);	//FindExptFolder();	//current_day = LoadOnWeights();	waiting_for_off = AmIWaitingForOff();	fclose(fp);		return(TRUE);	}long SearchForFolder (char *folder_name,long parent_dirID);void Experiment::FindExptFolder(void) {		char folder_name[50];	long parent_dirID;	long procID;	short parent_vRefNum;	OSErr err;		sprintf(folder_name,"%s data Ä",tag);	err= GetWDInfo (homeVol,&parent_vRefNum, &parent_dirID,&procID);	folder_dirID = SearchForFolder(folder_name,parent_dirID);}#define kMaxMatches 30 // find up to 30 matches in one pass#define kOptBufferSize 0x4000 // use a 16K search cache for speedlong SearchForFolder (char *folder_name,long parent_dirID) {   OSErr myErr;            // result code of function calls   short myCount;          // loop control variable   Str255 myFName;           // name of string to look for   short myVRefNum;          // volume to search   long myDirID;          // ignored directory ID for HGetVol	long folder_dirID;		CSParam myPB;   // HParamBlockRec myPB;   // parameter block for PBCatSearch   FSSpec *myMatches;	 // put matches here   CInfoPBRec mySpec1;       // search criteria, part 1   CInfoPBRec mySpec2;       // search criteria, part 2   char *myBuffer;                                 // search cache   Boolean done;          // have all matches been found?      myMatches = (FSSpec *)NewPtr(sizeof(FSSpec) * kMaxMatches);   myBuffer = NewPtr(kOptBufferSize);   myErr = HGetVol(NULL, &myVRefNum, &myDirID);                                          // search on the default volume   strcpy((char *)myFName,folder_name);          CtoPstr((char *)myFName);              // search for "foldername"	myPB.ioCompletion   = NULL;              // no completion routine	myPB.ioNamePtr      = NULL;              // no volume name; use vRefNum	myPB.ioVRefNum      = myVRefNum;        // volume to search	myPB.ioMatchPtr     = myMatches;                                      // points to results buffer	myPB.ioReqMatchCount= kMaxMatches;      // number of matches	myPB.ioSearchBits   = fsSBFullName    // search on full name                    	+ fsSBDrParID;     // search on directories parent id	myPB.ioSearchInfo1  = &mySpec1;         // points to first criteria set	myPB.ioSearchInfo2  = &mySpec2;         // points to second criteria set	myPB.ioSearchTime   = 0;                // no timeout on searches	myPB.ioCatPosition.initialize = 0;      // set hint to 0	myPB.ioOptBuffer = myBuffer;           // point to search cache	myPB.ioOptBufSize = kOptBufferSize;     // size of search cache	mySpec1.hFileInfo.ioNamePtr = myFName;              // point to string to find	mySpec1.hFileInfo.ioFlAttrib = 8;     	            // set bit 8 to ask for directories	mySpec1.dirInfo.ioDrParID = parent_dirID;			// the parent directory ID to search		mySpec2.hFileInfo.ioNamePtr = NULL;                 // set to NULL	mySpec2.hFileInfo.ioFlAttrib = 8;                  // set mask for bit 4	mySpec2.dirInfo.ioDrParID = parent_dirID;		// the parent directory ID to search   do {      myErr = PBCatSearchSync(&myPB);    // get some files      done = (myErr == eofErr);           // eofErr returned when all done      if (  ((myErr == noErr) || done) && (myPB.ioActMatchCount > 0)  ) {         for (myCount = 1;myCount <=  myPB.ioActMatchCount;  myCount++)            {                        	            	// report all matches found                                    }                                               }   } while (!done);	CInfoPBRec foldPB;			foldPB.dirInfo.ioCompletion = NULL;	foldPB.dirInfo.ioNamePtr  = myFName;	foldPB.dirInfo.ioFDirIndex = 0;	foldPB.dirInfo.ioVRefNum = -1;	foldPB.dirInfo.ioDrParID = 	parent_dirID;		myErr = PBGetCatInfo(&foldPB,FALSE);		if (parent_dirID != foldPB.dirInfo.ioDrParID) {			SysBeep(0);		}		folder_dirID = foldPB.dirInfo.ioDrDirID;		return(folder_dirID);}void Experiment::SetName(char *n) { strcpy(name,n);}void Experiment::SetTag(char *t) { strcpy(tag,t);}void Experiment::SetComment(char *c) {strcpy(comment,c); }void Experiment::SetStartTime(unsigned long s) { start_time = s; }void Experiment::SetEndTime(unsigned long e) {  end_time = e;}void Experiment::SetWaitingForOff(Boolean wait) { waiting_for_off = wait; }void Experiment::SetCurrentDay(DailyData *cd) { current_day = cd; }	unsigned long  Experiment::GetNumRats(void) { return(rats->GetNumMembers());}unsigned long  Experiment::GetNumItems(void) { return(items->GetNumMembers()); }unsigned long  Experiment::GetNumGroups(void) { return(groups->GetNumMembers()); }unsigned long  Experiment::GetNumDays(void) {return(days_of_data->GetNumMembers()); }ItemType *Experiment::GetAnItem(unsigned long i) { return ((ItemType *)(items->GetMember(i)));}short Experiment::GetItemIndex(ItemType *i) {	unsigned long j;	for (j=0;j<GetNumItems();j++) {			if (i == GetAnItem(j)) return(j);		}		return(-1);}void Experiment::GetName(char *n) { strcpy(n,name); }void Experiment::GetTag(char *t) { strcpy(t,tag); }void Experiment::GetTagName(char *tn) { sprintf(tn,"%s:%s",tag,name) ; }void Experiment::GetComment(char *c) {  strcpy(c,comment);}unsigned long Experiment::GetStartTime(void) { return(start_time); }unsigned long Experiment::GetEndTime(void) { return(end_time); }DailyData *Experiment::GetCurrentDay(void) { return(current_day); }ListObject *Experiment::GetRats(void) { return(rats); }ListObject *Experiment::GetItems(void) { return(items); }ListObject *Experiment::GetGroups(void) { return(groups); }ListObject *Experiment::GetDays(void) { return(days_of_data); }	Experiment *MatchTag2Expt(char *tag) {	Object *o;	Experiment *expt;	short i,l;	char expttag[32];	i = 0; l = strlen(tag);	while (isalpha(tag[i]) && i <= l) {		expttag[i] = toupper(tag[i]);		i++;	}	expttag[i] = '\0';	FORALL(o,allExpts) {			expt = (Experiment *)o;				if (strcmp(expttag,expt->tag) == 0) return(expt);	}		return(NULL);}short Experiment::Tag2Rat(char *tag) {	// first read the experiment letter code	// then read the numbers		short i,l,rat, rat_start;	char rattag[32];			i = 0; l = strlen(tag);	while (isalpha(tag[i]) && i <= l) i++;	rat_start = i;		while( isdigit(tag[i]) && i <= l) {			rattag[i-rat_start] = tag[i];		i++;	}	rattag[i-rat_start] = '\0';	rat = -1;	if (strlen(rattag) > 0) { 		sscanf(rattag,"%hd",&rat);		rat--;	}		if ( rat < 0 || rat >= GetNumRats()) rat = -1;		return(rat);	}ItemType *Experiment::Tag2Item(char *tag) {	// first read the experiment letter code	// then read the numbers	// then read the item code		short i,l,it, it_start;	char ittag[32];	ItemType *item;	Object *o;		i = 0; l = strlen(tag);	while (isalpha(tag[i]) && i <= l) i++;	while (isdigit(tag[i]) && i <= l) i++;			it_start = i;		while( isalpha(tag[i]) && i <= l) {			ittag[i-it_start] = toupper(tag[i]);		i++;	}	ittag[i-it_start] = '\0';	FORALL(o,items) {			item = (ItemType *)o;				if (strcmp(ittag,item->tag) == 0) return(item);	}			return(NULL);}Boolean Experiment::GetItemText(short rat,short itemIndex,char *ontext,char *offtext,char *deltatext) {	double onwgt, offwgt, deltawgt;	ItemType *item;	item = GetAnItem(itemIndex);		if (!GetWeights(rat,item,&onwgt,&offwgt,&deltawgt)) return(FALSE);		if (onwgt == MISSINGWGT) sprintf(ontext,"-");	else sprintf(ontext,"%.2f",onwgt);		if (offwgt == MISSINGWGT) sprintf(offtext,"-");	else sprintf(offtext,"%.2f",offwgt);		if (deltawgt == MISSINGWGT) sprintf(deltatext,"-");	else sprintf(deltatext,"%.2f",deltawgt);		return(TRUE);}Boolean Experiment::GetWeights(short rat, ItemType *item,double *onwgt,double *offwgt,double *deltawgt) {	short itemIndex;		itemIndex = GetItemIndex(item);		(*onwgt) = (*offwgt) = (*deltawgt) = MISSINGWGT;		if (0 <= rat && rat <= GetNumRats() && item != NULL) {			if (current_day == NULL) return(TRUE);				current_day->GetWeights(rat,itemIndex,onwgt,offwgt,deltawgt);		return(TRUE);					}	else {			return(FALSE);		}}void Experiment::ClearCurrentDay(void) {	if (current_day != NULL) delete current_day;		current_day = NULL;}void Experiment::SetOnWeight(short rat, ItemType *item,double weight) {	unsigned long itemIndex;		itemIndex = GetItemIndex(item);	if (current_day == NULL) current_day = new DailyData(GetNumRats(),GetNumItems());			current_day->SetOnWeight(rat,itemIndex,weight);	}void Experiment::SetOffWeight(short rat, ItemType *item,double weight) {	unsigned long itemIndex;		itemIndex = GetItemIndex(item);	if (current_day == NULL) current_day = LoadOnWeights();		current_day->SetOffWeight(rat,itemIndex,weight);}Boolean Experiment::SetExptFolderDirectory(void) {	OSErr err;	/*	if (folder_dirID != NULL) {		err = HSetVol(NULL, 0, folder_dirID);	}	if (err == noErr) return(TRUE);	else return (FALSE);		*/	return (FALSE);}void Experiment::SaveOnWeights(void) {		// save the current day on weights in a file named "tag on weights"	FILE *fp;	char name[100];	Str255 pname;	FInfo finderInfo;	OSErr err;		// to do the backing up prpoerly, save the file as "n.BAK"	// then swap "n" and "n.BAK" using file exchange call		SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program		// does the file exist already?	sprintf((char *)name,"%s on wgts",tag);	strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == fnfErr) {			// if not, create the expt data folder too...		// we'll skip the expt folders for the moment, store everything in the application folder		// CreateExptFolder();	}	else FixBackUps(name,homeVol);	fp = fopen(name,"w");		current_day->SaveOn(fp); // ask the daily data to save itself...		fclose(fp);		SetFileSignature(name,homeVol,'TEXT','BARt');		SetWaitingForOff(TRUE);		}Boolean Experiment::AmIWaitingForOff(void) {	FILE *fp;	char name[100];	Str255 pname;	FInfo finderInfo;	OSErr err;			SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program		// does the file exist already?	sprintf((char *)name,"%s on wgts",tag);	strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == noErr) {			// yes, on wgts are already on disk...			//so waiting_for_off		return(TRUE);	}		return(FALSE);}DailyData *Experiment::LoadOnWeights(void) {	FILE *fp;	char name[100];	Str255 pname;	FInfo finderInfo;	OSErr err;			SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program		// does the file exist already?	sprintf((char *)name,"%s on wgts",tag);	strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == noErr) {			// yes, on wgts are already on disk...	//		waiting_for_off = TRUE;			fp = fopen(name,"r");		// load the file named "tag on"		DailyData *dd = new DailyData(fp);		fclose(fp);		return(dd);	}	else {		// no, there is no file named "tag on"		DailyData *dd = new DailyData(GetNumRats(),GetNumItems());		waiting_for_off = FALSE;		return(dd);	}	return(NULL);}void Experiment::DeleteOnWeightsFile(void) {	// back up and rename the current day on weights in a file named "tag on weights"	FILE *fp;	char name[100];	Str255 pname;	FInfo finderInfo;	OSErr err;		// to do the backing up prpoerly, save the file as "n.BAK"	// then swap "n" and "n.BAK" using file exchange call		SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program		// does the file exist already?	sprintf((char *)name,"%s on wgts",tag);	strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == noErr) FixBackUps(name,homeVol);	// DeleteFile	}void Experiment::AbortOnWeighing(void) {	waiting_for_off = FALSE;	ClearCurrentDay();}void Experiment::AbortOffWeighing(void) {	waiting_for_off = TRUE;	ClearCurrentDay();}void Experiment::SaveOffWeights(void) {	//save the current day on and off weights	// in a file named "tag MM/DD/YY"	// where MM/DD/YY is the start date the weights were weighed ON	// we can tell from creation date when the weights were weighed off	// then backup the current weights on file, and delete the original	FILE *fp;	char name[100],date[30],hour[30];	Str255 pname;	FInfo finderInfo;	OSErr err;		// to do the backing up prpoerly, save the file as "n.BAK"	// then swap "n" and "n.BAK" using file exchange call		SetCursor(&Watch);	SetVol(0L,homeVol);	// everyone gets saved in the same directory as the program		// does the file exist already?	Secs2DateStr(current_day->onTime,date,SHORTDATE);	Secs2HourStr(current_day->onTime,hour,SHOWNOSECS);		sprintf((char *)name,"%s %s %s",tag,date,hour);	strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == fnfErr) {			// if not, create the expt data folder too...		// we'll skip the expt folders for the moment, store everything in the application folder		// CreateExptFolder();	}		fp = fopen(name,"w");		current_day->SaveOff(this,fp); // ask the daily data to save itself...		fclose(fp);	SetFileSignature(name,homeVol,'TEXT','BARt');		DeleteOnWeightsFile();		SetWaitingForOff(FALSE);			//DisplayProgress("OffWeights","Writing out cumul file");		// try appending all this data to a cumulative file	sprintf((char *)name,"%scuml.xls",tag);		// if no cumul file, then create and write headers		strcpy((char *)pname,name);	CtoPstr((char *)pname);	err = GetFInfo(pname,homeVol,&finderInfo);	if (err == fnfErr) {		CreateCumulativeFile(name);	}			current_day->SaveCumulative(this,name); // ask the daily data to save itself...			//DisplayProgress("OffWeights","Setting cumul file Sig");	SetFileSignature(name,homeVol,'TEXT','XCEL');		//DisplayProgress("OffWeights","Finished SaveOffweights");	//HideProgress();		}void TagRat2Text(char *tag, short rat, char *text) {		rat++;		if (rat < 10) {					sprintf(text,"%s00%d",tag,rat);				}		else if (rat < 100) {					sprintf(text,"%s0%d",tag,rat);				}		else if (rat < 100) {					sprintf(text,"%s%d",tag,rat);				}}void Experiment::ReplaceCumulFile(void) {	char datestring[100];	Str255 oldname,newname;	OSErr err;		FInfo finderInfo;			sprintf((char *)oldname,"%scuml.xls",tag);		Secs2DateStr(SecsNow(),datestring,SHORTDATE);	sprintf((char *)newname,"%scuml %s.xls",tag,datestring); 		// if no cumul file, then create and write headers		CtoPstr((char *)oldname);	CtoPstr((char *)newname);		err = GetFInfo(oldname,homeVol,&finderInfo);	if (err == noErr) {			err = HRename (vRefNum, 0L, oldname, newname);	}}#define WGT(x,y,z) ((*x)[y*numItems+z])DailyData::DailyData(short nRats,short nItems) {	numRats = nRats;	numItems = nItems;		onWeight = offWeight = NULL;		InitWeights();}void DailyData::InitWeights(void) {	short r,i;	onWeight = offWeight = NULL;			onWeight = (double **)NewHandle(sizeof(double) * numRats * numItems);	offWeight = (double **)NewHandle(sizeof(double) * numRats * numItems);		if (onWeight != NULL && offWeight != NULL) {		for (r=0;r < numRats; r++) {			for (i=0;i<numItems;i++) {				WGT(onWeight,r,i) = MISSINGWGT; 				WGT(offWeight,r,i) = MISSINGWGT; 			}					}	}}Boolean DailyData::GetWeights(short rat, short itemIndex,double *onwgt,double *offwgt,double *deltawgt) {	(*onwgt) = (*offwgt) = (*deltawgt) = MISSINGWGT;	if (onWeight == NULL || offWeight == NULL)  return(FALSE);	if ( rat < 0 || numRats <= rat) return(FALSE);	if ( itemIndex < 0 || numItems <= itemIndex) return(FALSE);		(*onwgt) = WGT(onWeight,rat,itemIndex);	(*offwgt) = WGT(offWeight,rat,itemIndex);		if (WGT(onWeight,rat,itemIndex) != MISSINGWGT && WGT(offWeight,rat,itemIndex) != MISSINGWGT) {			(*deltawgt) = WGT(onWeight,rat,itemIndex) - WGT(offWeight,rat,itemIndex);	}		return(TRUE);	}void Test(void);void DailyData::SaveOn(FILE *fp) {		short r,i;	char datetime[100];	if (onWeight == NULL || offWeight == NULL)  return;				onTime = SecsNow();	Secs2TimeStr(onTime,datetime,SHORTDATE,HRCOLON);	fprintf(fp,"Time On (s):\t%lu\tDate:\t%s\t \n",onTime,datetime);		fprintf(fp,"Rats:\t%d\tItems:\t%d \t\n",numRats,numItems);	for (r=0;r < numRats; r++) {			for (i=0;i<numItems;i++) {					fprintf(fp,"%.2f\t",WGT(onWeight,r,i));						}		fprintf(fp,"\n");		}	}void DailyData::SaveOff(Experiment *expt,FILE *fp) {		short r,i;	char ondatetime[100],offdatetime[100];	ItemType *item;	double onwgt,offwgt,deltawgt;	if (onWeight == NULL || offWeight == NULL)  return;		offTime = SecsNow();	Secs2TimeStr(onTime,ondatetime,SHORTDATE,HRCOLON);	Secs2TimeStr(offTime,offdatetime,SHORTDATE,HRCOLON);	fprintf(fp,"Time On (s):\t%lu\tDate:\t%s\t \n",onTime,ondatetime);	fprintf(fp,"Time Off (s):\t%lu\tDate:\t%s\t \n",offTime,offdatetime);				fprintf(fp,"Rats:\t%d\tItems:\t%d \t\n",numRats,numItems);	for (i=0;i<numItems;i++) {			// get item name			item = expt->GetAnItem(i);			fprintf(fp,"%s ON\t",item->name);			fprintf(fp,"%s OFF\t",item->name);			fprintf(fp,"%s Delta\t",item->name);		}	fprintf(fp,"\n");	for (r=0;r < numRats; r++) {			for (i=0;i<numItems;i++) {					GetWeights(r,i,&onwgt,&offwgt,&deltawgt);					fprintf(fp,"%.2f\t",onwgt);			fprintf(fp,"%.2f\t",offwgt);			fprintf(fp,"%.2f\t",deltawgt);						}		fprintf(fp,"\n");		}	}void Experiment::CreateCumulativeFile(char *name) {	FILE *fp;	short r,i;	ItemType *item;	char ratname[32],prefname[50],tagname[50];	short numRats,numItems;	RatType *rat;	GroupType *group;	TextTable *table;	char empty[32];			numRats = GetNumRats();	numItems = GetNumItems();		sprintf(empty,"     ");		// start the 1st column == rat names	table = new TextTable();		table->AddLastColumn();		GetTagName(tagname);	table->AddCellToLastColumn(tagname);	table->AddCellToLastColumn(comment);		table->AddCellToLastColumn(empty); // spacer		table->AddCellToLastColumn(empty); // on time	table->AddCellToLastColumn("Subject"); // off time		// spacer line between on & off times and items	table->AddCellToLastColumn(empty);					if (HasPreference()) {			for (r=0;r < numRats; r++) {			TagRat2Text(tag,r,ratname);			table->AddCellToLastColumn(ratname);		}						// 3 spacer lines between preference and items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		}	for (i=0;i<numItems;i++) {		for (r=0;r < numRats; r++) {					TagRat2Text(tag,r,ratname);			table->AddCellToLastColumn(ratname);		}			// 3 spacer lines between items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);			}	// start the 2nd column == group names	table->AddLastColumn();		table->AddCellToLastColumn(empty); // tagname	table->AddCellToLastColumn(empty); // comment		table->AddCellToLastColumn(empty); // spacer		table->AddCellToLastColumn(empty); // time on	table->AddCellToLastColumn("Group"); // time off		// spacer line between on & off times and items	table->AddCellToLastColumn(empty);					if (HasPreference()) {			for (r=0;r < numRats; r++) {			rat = (RatType *)rats->GetMember(r);			group = (GroupType *)groups->GetMember(rat->group);			table->AddCellToLastColumn(group->tag);		}						// 3 spacer lines between preference and items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		}	for (i=0;i<numItems;i++) {		for (r=0;r < numRats; r++) {			rat = (RatType *)rats->GetMember(r);			group = (GroupType *)groups->GetMember(rat->group);			table->AddCellToLastColumn(group->tag);		}				// 3 spacer lines between items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);			}	// start the 3rd column == item names	table->AddLastColumn();		table->AddCellToLastColumn(empty); // tagname	table->AddCellToLastColumn(empty); // comment	table->AddCellToLastColumn(empty); // spacer	table->AddCellToLastColumn("Time on:");	table->AddCellToLastColumn("Item");		// spacer line between on & off times and items	table->AddCellToLastColumn(empty);					if (HasPreference()) {		GetPreferenceText(prefname);		for (r=0;r < numRats; r++) {			table->AddCellToLastColumn(prefname);		}						// 3 spacer lines between preference and items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		}	for (i=0;i<numItems;i++) {			item = GetAnItem(i);		for (r=0;r < numRats; r++) {			table->AddCellToLastColumn(item->name);		}				// 3 spacer lines between items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);			}	// write table out to file...			fp = fopen(name,"w");	table->WriteTableToFile(fp);	fclose(fp);	}void DailyData::SaveCumulative(Experiment *expt,char *name) {		short r,i;	char ondatetime[100],offdatetime[100],text[50],empty[32];	ItemType *item;	double onwgt,offwgt,deltawgt;	TextTable *table;		FILE *fp;	if (onWeight == NULL || offWeight == NULL)  return;		sprintf(empty,"     ");		table = new TextTable();		fp = fopen(name,"r");	table->ReadTableFromFile(fp);	fclose(fp);		// back up the old file after we read it in	FixBackUps(name,homeVol);		table->AddLastColumn();		table->AddCellToLastColumn(empty); // tagname	table->AddCellToLastColumn(empty); // comment		table->AddCellToLastColumn(empty); // spacer		Secs2TimeStr(onTime,ondatetime,SHORTDATE,HRCOLON);	Secs2TimeStr(offTime,offdatetime,SHORTDATE,HRCOLON);			table->AddCellToLastColumn(ondatetime);	table->AddCellToLastColumn(offdatetime);		// spacer line between on & off times and items	table->AddCellToLastColumn(empty);					if (expt->HasPreference()) {			for (r=0;r < numRats; r++) {			expt->GetPrefScoreText(r,text);			table->AddCellToLastColumn(text);		}				// 3 spacer lines between preference and items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		}	for (i=0;i<numItems;i++) {		for (r=0;r < numRats; r++) {					GetWeights(r,i,&onwgt,&offwgt,&deltawgt);				if (deltawgt != MISSINGWGT) {					sprintf(text,"%.2f\t",deltawgt);				}				else {					sprintf(text,"--\t");				}				table->AddCellToLastColumn(text);		}			// 3 spacer lines between items			table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);		table->AddCellToLastColumn(empty);			}		// write the table out...		fp = fopen(name,"w");	table->WriteTableToFile(fp);	fclose(fp);	}// if groups changed, just overwrite old groups//if number of rats or number of items or preference changed, // then back up old cumulative and start anotherDailyData::~DailyData() {	if (onWeight != NULL) DisposHandle((Handle)onWeight);	if (offWeight != NULL) DisposHandle((Handle)offWeight);	}DailyData::DailyData(FILE *fp) {	char name[50],text[50];	short r,i;		onWeight = offWeight = NULL;		LineBuffer *line;	double input;			line = NewLineBuffer(1000);	if (fp == NULL) return;		GetNextLine(line,fp); 		// get the weigh-on time	GetNextTabField(line,text);		// "Time On:"		GetNextTabField(line,text);sscanf(text,"%lu",&onTime);					GetNextLine(line,fp); 		// number of rats and items		GetNextTabField(line,text);		// "Rats:"	GetNextTabField(line,text);sscanf(text,"%hd",&numRats);					GetNextTabField(line,text);		// "Items:"	GetNextTabField(line,text);sscanf(text,"%hd",&numItems);		InitWeights();	if (onWeight != NULL || offWeight != NULL)  {		for (r=0;r < numRats; r++) {			if (GetNextLine(line,fp)) {				for (i=0;i<numItems;i++) {					if (GetNextTabField(line,text) )							sscanf(text,"%lf",&input);								(WGT(onWeight,r,i))	= input;					}			}		}	}		fclose(fp);		DisposeLineBuffer(line);}void DailyData::SetOnWeight(short rat,short itemIndex,double wgt) {	if (onWeight != NULL) WGT(onWeight,rat,itemIndex) = wgt;}void DailyData::SetOffWeight(short rat,short itemIndex,double wgt) {	if (offWeight != NULL) WGT(offWeight,rat,itemIndex) = wgt;}void DailyData::ClearOnWeights(void) {	unsigned long r,i;	if (onWeight != NULL) {		for(r = 0;r < numRats;r++) {			for (i=0;i<numItems;i++) {				WGT(onWeight,r,i) = MISSINGWGT;				WGT(offWeight,r,i) = MISSINGWGT;			}		}		}			}			void DailyData::ClearOffWeights(void) {	unsigned long r,i;		if (offWeight != NULL) {		for(r = 0;r < numRats;r++) {			for (i=0;i<numItems;i++) {				WGT(offWeight,r,i) = MISSINGWGT;			}		}		}			}																							unsigned long Experiment::GetUnWeighedOnItems(void) { return(current_day->GetUnWeighedOnItems());}unsigned long Experiment::GetUnWeighedOffItems(void){ return(current_day->GetUnWeighedOffItems());}				unsigned long DailyData::GetUnWeighedOnItems(void) {	unsigned long unweighed = 0;	unsigned long r,i;		if (onWeight != NULL) {		for(r = 0;r < numRats;r++) {			for (i=0;i<numItems;i++) {				if (WGT(onWeight,r,i) == MISSINGWGT) unweighed++;			}		}		}			return(unweighed);}	unsigned long DailyData::GetUnWeighedOffItems(void)  {	unsigned long unweighed = 0;	unsigned long r,i;		if (offWeight != NULL) {		for(r = 0;r < numRats;r++) {			for (i=0;i<numItems;i++) {				if (WGT(offWeight,r,i) == MISSINGWGT) unweighed++;			}		}		}			return(unweighed);}					void Experiment::GetPreferenceText(char *text) {	if (hasPreference) {		sprintf(text,"%s / %s",((ItemType *)(items->GetMember(prefItem)))->name,			((ItemType *)(items->GetMember(baseItem)))->name);	}	else {		sprintf(text,"No Preference");	}}				Boolean Experiment::HasPreference(void) { return(hasPreference); }void Experiment::GetPreference(unsigned long *s,unsigned long *w) {	(*s) = prefItem;	(*w) = baseItem;}void Experiment::SetPreference(Boolean hasPref,unsigned long s, unsigned long w) {	hasPreference = hasPref;	if (hasPreference) {			prefItem = s;		baseItem = w;			}}void Experiment::GetPrefScore(short rat, double *pref) {	double onwgt, offwgt,pref_deltawgt,base_deltawgt;	(*pref) = MISSINGWGT;	if (hasPreference) {				if (GetWeights(rat, GetAnItem(prefItem),&onwgt,&offwgt,&pref_deltawgt) &&			GetWeights(rat, GetAnItem(baseItem),&onwgt,&offwgt,&base_deltawgt) ) {							if (pref_deltawgt >= 0 && base_deltawgt >= 0) {							if (pref_deltawgt != MISSINGWGT && base_deltawgt != MISSINGWGT &&  (pref_deltawgt + base_deltawgt) != 0) {											(*pref) = pref_deltawgt / (pref_deltawgt + base_deltawgt);										}					}		}		}}void Experiment::GetPrefScoreText(short rat, char *text) {	double pref;	GetPrefScore(rat,&pref);		if (pref != MISSINGWGT) { sprintf(text,"%.2lf",pref); }	else { sprintf(text,"--",pref); }	}void Experiment::SetSequentialGroups(void) {	unsigned long numRats, numGroups, ratsPerGroup,i;	numRats = GetNumRats();	numGroups = GetNumGroups();	ratsPerGroup = numRats/numGroups;		for (i=0;i<numRats;i++) {				((RatType *)(rats->GetMember(i)))->group = i/ratsPerGroup;	}		}void Experiment::SetAlternatingGroups(void) {	unsigned long numRats, numGroups, i;	numRats = GetNumRats();	numGroups = GetNumGroups();			for (i=0;i<numRats;i++) {				((RatType *)(rats->GetMember(i)))->group = i % numGroups;	}}